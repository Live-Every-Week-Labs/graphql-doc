import { DocModel, Section, Subsection, Operation, ExpandedType } from '../../transformer/types';
import { slugify } from '../../utils/string-utils';

export interface SidebarItem {
  type: 'category' | 'doc' | 'link' | 'autogenerated';
  label?: string;
  id?: string; // For 'doc' type
  href?: string; // For 'link' type
  items?: SidebarItem[]; // For 'category' type
  link?: { type: 'generated-index' | 'doc'; id?: string }; // For category links
  collapsed?: boolean;
  collapsible?: boolean;
  className?: string;
  customProps?: Record<string, unknown>;
}

export type SidebarConfig = Record<string, SidebarItem[]>;

export class SidebarGenerator {
  generate(model: DocModel): SidebarItem[] {
    const sidebarItems: SidebarItem[] = [];

    for (const section of model.sections) {
      sidebarItems.push(this.generateSectionItem(section));
    }

    const typeSection = this.generateTypesSection(model.types);
    if (typeSection) {
      sidebarItems.push(typeSection);
    }

    return sidebarItems;
  }

  /**
   * Generate a sidebar for single-page mode with hash links for in-page navigation.
   * @param model - The documentation model
   * @param docId - The document ID (e.g., 'api-reference')
   * @returns Array of sidebar items with hash links
   */
  generateSinglePageSidebar(model: DocModel, docId: string): SidebarItem[] {
    const sidebarItems: SidebarItem[] = [];

    for (const section of model.sections) {
      sidebarItems.push(this.generateSinglePageSectionItem(section, docId));
    }

    const typeSection = this.generateSinglePageTypesSection(model.types, docId);
    if (typeSection) {
      sidebarItems.push(typeSection);
    }

    return sidebarItems;
  }

  private generateSinglePageSectionItem(section: Section, docId: string): SidebarItem {
    const sectionSlug = slugify(section.name);
    const items: SidebarItem[] = [];

    for (const subsection of section.subsections) {
      if (subsection.name === '') {
        // Root subsection operations go directly into the section items
        for (const op of subsection.operations) {
          items.push(this.generateSinglePageOperationItem(op, docId));
        }
      } else {
        // Named subsections become nested categories
        items.push(this.generateSinglePageSubsectionItem(subsection, sectionSlug, docId));
      }
    }

    return {
      type: 'category',
      label: section.name,
      link: {
        type: 'doc',
        id: docId,
      },
      items: items,
      collapsible: true,
      collapsed: true,
    };
  }

  private generateSinglePageSubsectionItem(
    subsection: Subsection,
    sectionSlug: string,
    docId: string
  ): SidebarItem {
    const subsectionSlug = slugify(subsection.name);
    const anchorId = `${sectionSlug}-${subsectionSlug}`;

    const items: SidebarItem[] = subsection.operations.map((op) =>
      this.generateSinglePageOperationItem(op, docId)
    );

    return {
      type: 'category',
      label: subsection.name,
      link: {
        type: 'doc',
        id: docId,
      },
      items: items,
      collapsible: true,
      collapsed: true,
      customProps: {
        anchor: anchorId,
      },
    };
  }

  private generateSinglePageOperationItem(operation: Operation, docId: string): SidebarItem {
    const opSlug = slugify(operation.name);
    return {
      type: 'link',
      label: operation.name,
      href: `${docId}#${opSlug}`,
    };
  }

  private generateSectionItem(section: Section): SidebarItem {
    const sectionPath = slugify(section.name);
    const items: SidebarItem[] = [];

    for (const subsection of section.subsections) {
      if (subsection.name === '') {
        // Root subsection operations go directly into the section items
        for (const op of subsection.operations) {
          items.push(this.generateOperationItem(op, sectionPath));
        }
      } else {
        // Named subsections become nested categories
        items.push(this.generateSubsectionItem(subsection, sectionPath));
      }
    }

    return {
      type: 'category',
      label: section.name,
      link: {
        type: 'generated-index',
      },
      items: items,
      collapsible: true,
      collapsed: true,
    };
  }

  private generateSubsectionItem(subsection: Subsection, parentPath: string): SidebarItem {
    const subsectionSlug = slugify(subsection.name);
    const subsectionPath = `${parentPath}/${subsectionSlug}`;

    const items: SidebarItem[] = subsection.operations.map((op) =>
      this.generateOperationItem(op, subsectionPath)
    );

    return {
      type: 'category',
      label: subsection.name,
      link: {
        type: 'generated-index',
      },
      items: items,
      collapsible: true,
      collapsed: true,
    };
  }

  private generateOperationItem(operation: Operation, parentPath: string): SidebarItem {
    const opSlug = slugify(operation.name);
    return {
      type: 'doc',
      id: `${parentPath}/${opSlug}`,
      label: operation.name,
    };
  }

  private generateTypesSection(types: ExpandedType[]): SidebarItem | null {
    const typeGroups = this.groupTypes(types);

    if (typeGroups.enums.length + typeGroups.inputs.length + typeGroups.types.length === 0) {
      return null;
    }

    return {
      type: 'category',
      label: 'Types',
      link: { type: 'generated-index' },
      items: [
        this.generateTypeCategory('Enums', 'types/enums', typeGroups.enums),
        this.generateTypeCategory('Inputs', 'types/inputs', typeGroups.inputs),
        this.generateTypeCategory('Types', 'types/types', typeGroups.types),
      ],
      collapsible: true,
      collapsed: true,
      className: 'gql-sidebar-types',
    };
  }

  private generateSinglePageTypesSection(types: ExpandedType[], docId: string): SidebarItem | null {
    const typeGroups = this.groupTypes(types);

    if (typeGroups.enums.length + typeGroups.inputs.length + typeGroups.types.length === 0) {
      return null;
    }

    return {
      type: 'category',
      label: 'Types',
      link: { type: 'doc', id: docId },
      items: [
        this.generateSinglePageTypeCategory('Enums', 'types-enums', typeGroups.enums, docId),
        this.generateSinglePageTypeCategory('Inputs', 'types-inputs', typeGroups.inputs, docId),
        this.generateSinglePageTypeCategory('Types', 'types-types', typeGroups.types, docId),
      ],
      collapsible: true,
      collapsed: true,
      className: 'gql-sidebar-types',
      customProps: {
        anchor: 'types',
      },
    };
  }

  private generateTypeCategory(
    label: string,
    parentPath: string,
    types: ExpandedType[]
  ): SidebarItem {
    return {
      type: 'category',
      label,
      link: { type: 'generated-index' },
      items: types.map((type) => ({
        type: 'doc',
        id: `${parentPath}/${slugify((type as { name: string }).name)}`,
        label: (type as { name: string }).name,
      })),
      collapsible: true,
      collapsed: true,
    };
  }

  private generateSinglePageTypeCategory(
    label: string,
    anchor: string,
    types: ExpandedType[],
    docId: string
  ): SidebarItem {
    return {
      type: 'category',
      label,
      link: { type: 'doc', id: docId },
      items: types.map((type) => ({
        type: 'link',
        label: (type as { name: string }).name,
        href: `${docId}#${slugify((type as { name: string }).name)}`,
      })),
      collapsible: true,
      collapsed: true,
      customProps: {
        anchor,
      },
    };
  }

  private groupTypes(types: ExpandedType[]) {
    const enums: ExpandedType[] = [];
    const inputs: ExpandedType[] = [];
    const objectTypes: ExpandedType[] = [];

    for (const type of types) {
      if (!('name' in type)) {
        continue;
      }
      if (type.kind === 'ENUM') {
        enums.push(type);
      } else if (type.kind === 'INPUT_OBJECT') {
        inputs.push(type);
      } else if (
        type.kind === 'OBJECT' ||
        type.kind === 'INTERFACE' ||
        type.kind === 'UNION' ||
        type.kind === 'SCALAR'
      ) {
        objectTypes.push(type);
      }
    }

    const byName = (a: ExpandedType, b: ExpandedType) =>
      (a as { name: string }).name.localeCompare((b as { name: string }).name);

    return {
      enums: enums.sort(byName),
      inputs: inputs.sort(byName),
      types: objectTypes.sort(byName),
    };
  }
}
