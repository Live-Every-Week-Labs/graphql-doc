import { DocModel, Section, Subsection, Operation, ExpandedType } from '../../transformer/types';
import { slugify } from '../../utils/string-utils';

export interface SidebarItem {
  type: 'category' | 'doc' | 'link' | 'autogenerated' | 'html';
  label?: string;
  id?: string; // For 'doc' type
  href?: string; // For 'link' type
  items?: SidebarItem[]; // For 'category' type
  link?: { type: 'generated-index' | 'doc'; id?: string }; // For category links
  value?: string; // For 'html' type
  defaultStyle?: boolean; // For 'html' type
  collapsed?: boolean;
  collapsible?: boolean;
  className?: string;
  customProps?: Record<string, unknown>;
}

export type SidebarConfig = Record<string, SidebarItem[]>;

export interface SidebarGeneratorConfig {
  categoryIndex?: boolean;
  sectionLabels?: {
    operations?: string;
    types?: string;
  };
  docIdPrefix?: string;
}

export class SidebarGenerator {
  private config: SidebarGeneratorConfig;

  constructor(config: SidebarGeneratorConfig = {}) {
    this.config = config;
  }

  private getDocIdPrefix(): string {
    const prefix = this.config.docIdPrefix;
    if (!prefix) return '';
    return prefix.replace(/\\/g, '/').replace(/^\/+|\/+$/g, '');
  }

  private withDocIdPrefix(id: string): string {
    const prefix = this.getDocIdPrefix();
    if (!prefix) return id;
    return `${prefix}/${id}`;
  }

  generate(model: DocModel): SidebarItem[] {
    const operations = this.generateOperationItems(model);
    const types = this.generateTypeCategories(model.types);
    const sidebarItems: SidebarItem[] = [];

    if (operations.length > 0) {
      sidebarItems.push(this.buildSectionHeader(this.getSectionLabel('operations')));
      sidebarItems.push(...operations);
    }

    if (types.length > 0) {
      if (sidebarItems.length > 0) {
        sidebarItems.push(this.buildDivider());
      }
      sidebarItems.push(this.buildSectionHeader(this.getSectionLabel('types')));
      sidebarItems.push(...types);
    }

    return sidebarItems;
  }

  /**
   * Generate a sidebar for single-page mode with hash links for in-page navigation.
   * @param model - The documentation model
   * @param docId - The document ID (e.g., 'api-reference')
   * @returns Array of sidebar items with hash links
   */
  generateSinglePageSidebar(model: DocModel, docId: string): SidebarItem[] {
    const operations = this.generateSinglePageOperationItems(model, docId);
    const types = this.generateSinglePageTypeCategories(model.types, docId);
    const sidebarItems: SidebarItem[] = [];

    if (operations.length > 0) {
      sidebarItems.push(this.buildSectionHeader(this.getSectionLabel('operations')));
      sidebarItems.push(...operations);
    }

    if (types.length > 0) {
      if (sidebarItems.length > 0) {
        sidebarItems.push(this.buildDivider());
      }
      sidebarItems.push(this.buildSectionHeader(this.getSectionLabel('types')));
      sidebarItems.push(...types);
    }

    return sidebarItems;
  }

  private getSectionLabel(section: 'operations' | 'types'): string {
    if (section === 'operations') {
      return this.config.sectionLabels?.operations ?? 'Operations';
    }
    return this.config.sectionLabels?.types ?? 'Types';
  }

  private buildSectionHeader(label: string): SidebarItem {
    const safeLabel = label.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
    return {
      type: 'html',
      value: `<div class="gql-sidebar-section-title">${safeLabel}</div>`,
      defaultStyle: true,
    };
  }

  private buildDivider(): SidebarItem {
    return { type: 'html', value: '<hr class="gql-sidebar-divider" />', defaultStyle: true };
  }

  private generateOperationItems(model: DocModel): SidebarItem[] {
    const items: SidebarItem[] = [];
    for (const section of model.sections) {
      items.push(this.generateSectionItem(section));
    }
    return items;
  }

  private generateSinglePageOperationItems(model: DocModel, docId: string): SidebarItem[] {
    const items: SidebarItem[] = [];
    for (const section of model.sections) {
      items.push(this.generateSinglePageSectionItem(section, docId));
    }
    return items;
  }

  private generateSinglePageSectionItem(section: Section, docId: string): SidebarItem {
    const sectionSlug = slugify(section.name);
    const items: SidebarItem[] = [];

    for (const subsection of section.subsections) {
      if (subsection.name === '') {
        // Root subsection operations go directly into the section items
        for (const op of subsection.operations) {
          items.push(this.generateSinglePageOperationItem(op, docId));
        }
      } else {
        // Named subsections become nested categories
        items.push(this.generateSinglePageSubsectionItem(subsection, sectionSlug, docId));
      }
    }

    const item: SidebarItem = {
      type: 'category',
      label: section.name,
      items: items,
      collapsible: true,
      collapsed: true,
    };
    if (this.config.categoryIndex) {
      item.link = { type: 'doc', id: docId };
    }
    return item;
  }

  private generateSinglePageSubsectionItem(
    subsection: Subsection,
    sectionSlug: string,
    docId: string
  ): SidebarItem {
    const subsectionSlug = slugify(subsection.name);
    const anchorId = `${sectionSlug}-${subsectionSlug}`;

    const items: SidebarItem[] = subsection.operations.map((op) =>
      this.generateSinglePageOperationItem(op, docId)
    );

    const item: SidebarItem = {
      type: 'category',
      label: subsection.name,
      items: items,
      collapsible: true,
      collapsed: true,
      customProps: {
        anchor: anchorId,
      },
    };
    if (this.config.categoryIndex) {
      item.link = { type: 'doc', id: docId };
    }
    return item;
  }

  private generateSinglePageOperationItem(operation: Operation, docId: string): SidebarItem {
    const opSlug = slugify(operation.name);
    const label = operation.directives.docGroup?.sidebarTitle ?? operation.name;
    return {
      type: 'link',
      label,
      href: `${docId}#${opSlug}`,
    };
  }

  private generateSectionItem(section: Section): SidebarItem {
    const sectionPath = slugify(section.name);
    const items: SidebarItem[] = [];

    for (const subsection of section.subsections) {
      if (subsection.name === '') {
        // Root subsection operations go directly into the section items
        for (const op of subsection.operations) {
          items.push(this.generateOperationItem(op, sectionPath));
        }
      } else {
        // Named subsections become nested categories
        items.push(this.generateSubsectionItem(subsection, sectionPath));
      }
    }

    const item: SidebarItem = {
      type: 'category',
      label: section.name,
      items: items,
      collapsible: true,
      collapsed: true,
    };
    if (this.config.categoryIndex) {
      item.link = { type: 'generated-index' };
    }
    return item;
  }

  private generateSubsectionItem(subsection: Subsection, parentPath: string): SidebarItem {
    const subsectionSlug = slugify(subsection.name);
    const subsectionPath = `${parentPath}/${subsectionSlug}`;

    const items: SidebarItem[] = subsection.operations.map((op) =>
      this.generateOperationItem(op, subsectionPath)
    );

    const item: SidebarItem = {
      type: 'category',
      label: subsection.name,
      items: items,
      collapsible: true,
      collapsed: true,
    };
    if (this.config.categoryIndex) {
      item.link = { type: 'generated-index' };
    }
    return item;
  }

  private generateOperationItem(operation: Operation, parentPath: string): SidebarItem {
    const opSlug = slugify(operation.name);
    const label = operation.directives.docGroup?.sidebarTitle ?? operation.name;
    return {
      type: 'doc',
      id: this.withDocIdPrefix(`${parentPath}/${opSlug}`),
      label,
    };
  }

  private generateTypeCategories(types: ExpandedType[]): SidebarItem[] {
    const typeGroups = this.groupTypes(types);
    if (typeGroups.enums.length + typeGroups.inputs.length + typeGroups.types.length === 0) {
      return [];
    }

    return [
      this.generateTypeCategory('Enums', 'types/enums', typeGroups.enums),
      this.generateTypeCategory('Inputs', 'types/inputs', typeGroups.inputs),
      this.generateTypeCategory('Types', 'types/types', typeGroups.types),
    ];
  }

  private generateSinglePageTypeCategories(types: ExpandedType[], docId: string): SidebarItem[] {
    const typeGroups = this.groupTypes(types);
    if (typeGroups.enums.length + typeGroups.inputs.length + typeGroups.types.length === 0) {
      return [];
    }

    return [
      this.generateSinglePageTypeCategory('Enums', 'types-enums', typeGroups.enums, docId),
      this.generateSinglePageTypeCategory('Inputs', 'types-inputs', typeGroups.inputs, docId),
      this.generateSinglePageTypeCategory('Types', 'types-types', typeGroups.types, docId),
    ];
  }

  private generateTypeCategory(
    label: string,
    parentPath: string,
    types: ExpandedType[]
  ): SidebarItem {
    const item: SidebarItem = {
      type: 'category',
      label,
      items: types.map((type) => ({
        type: 'doc',
        id: this.withDocIdPrefix(`${parentPath}/${slugify((type as { name: string }).name)}`),
        label: (type as { name: string }).name,
      })),
      collapsible: true,
      collapsed: true,
    };
    if (this.config.categoryIndex) {
      item.link = { type: 'generated-index' };
    }
    return item;
  }

  private generateSinglePageTypeCategory(
    label: string,
    anchor: string,
    types: ExpandedType[],
    docId: string
  ): SidebarItem {
    const item: SidebarItem = {
      type: 'category',
      label,
      items: types.map((type) => ({
        type: 'link',
        label: (type as { name: string }).name,
        href: `${docId}#${slugify((type as { name: string }).name)}`,
      })),
      collapsible: true,
      collapsed: true,
      customProps: {
        anchor,
      },
    };
    if (this.config.categoryIndex) {
      item.link = { type: 'doc', id: docId };
    }
    return item;
  }

  private groupTypes(types: ExpandedType[]) {
    const enums: ExpandedType[] = [];
    const inputs: ExpandedType[] = [];
    const objectTypes: ExpandedType[] = [];

    for (const type of types) {
      if (!('name' in type)) {
        continue;
      }
      if (type.kind === 'ENUM') {
        enums.push(type);
      } else if (type.kind === 'INPUT_OBJECT') {
        inputs.push(type);
      } else if (
        type.kind === 'OBJECT' ||
        type.kind === 'INTERFACE' ||
        type.kind === 'UNION' ||
        type.kind === 'SCALAR'
      ) {
        objectTypes.push(type);
      }
    }

    const byName = (a: ExpandedType, b: ExpandedType) =>
      (a as { name: string }).name.localeCompare((b as { name: string }).name);

    return {
      enums: enums.sort(byName),
      inputs: inputs.sort(byName),
      types: objectTypes.sort(byName),
    };
  }
}
